#include <sys/stat.h>
#include <string.h>
#include <errno.h>
#include <limits.h>

#include "freertos/FreeRTOS.h"
#include "freertos/semphr.h"

#include "esp_log.h"
#include "esp_crc.h"

#include "ocpp_task.h"
#include "ocpp_listener.h"
#include "ocpp_auth.h"
#include "messages/call_messages/ocpp_call_request.h"
#include "types/ocpp_charge_point_error_code.h"
#include "sdkconfig.h"

#include "types/ocpp_update_status.h"
#include "types/ocpp_id_token.h"

static const char * TAG = "OCPP AUTH      ";

struct auth_header{
	int file_version;
	int list_version;
	size_t token_count;
};

struct auth_tag_info{
	time_t expiry_date;
	ocpp_id_token parent_tag;
	uint8_t status;
};

struct auth_crc_content{
	ocpp_id_token id_tag;
	struct auth_tag_info id_tag_info;
};

struct auth_tag_entry{
	struct auth_tag_info id_tag_info;
	uint32_t crc_tag;
	time_t written_timestamp;
};

#define DIRECTORY_PATH CONFIG_OCPP_FILE_PATH "/auth"

static const char * auth_list_path = DIRECTORY_PATH "/auth_lst.bin";
static const char * auth_list_tmp_path = DIRECTORY_PATH "/auth_lst.tmp";
static const char * auth_cache_path = DIRECTORY_PATH "/auth_cah.bin";

#define OFFSET_HEADER 0
#define OFFSET_TOKEN_LIST OFFSET_HEADER + sizeof(struct auth_header) + sizeof(uint32_t)

#define OFFSET_TAG_LIST_AUTH_LIST OFFSET_TOKEN_LIST + (sizeof(ocpp_id_token) * CONFIG_OCPP_LOCAL_AUTH_LIST_MAX_LENGTH)
#define OFFSET_TAG_LIST_AUTH_CACHE OFFSET_TOKEN_LIST + (sizeof(ocpp_id_token) * CONFIG_OCPP_AUTH_CACHE_MAX_LENGTH)

static SemaphoreHandle_t file_lock = NULL;

bool local_pre_authorize = true;
bool authorize_offline = true;
bool auth_list_enabled = true;
bool auth_cache_enabled = true;
bool allow_offline_for_unknown = false;

void ocpp_change_local_pre_authorize(bool new_value){
	local_pre_authorize = new_value;
}

void ocpp_change_authorize_offline(bool new_value){
	authorize_offline = new_value;
}

void ocpp_change_auth_list_enabled(bool new_value){
	auth_list_enabled = new_value;
}

void ocpp_change_auth_cache_enabled(bool new_value){
	auth_cache_enabled = new_value;

	if(new_value == false){
		struct stat st;
		if(stat(auth_cache_path, &st) == 0){
			ESP_LOGW(TAG, "Authorization cache disabled. Clearing cache");
			ocpp_auth_clear_cache();
		}
	}
}

void ocpp_change_allow_offline_for_unknown(bool new_value){
	allow_offline_for_unknown = new_value;
}

/* File format currently used by both authorization list and authorization cache:
 * <header>: at OFFSET_HEADER
 * <token_list>: at OFFSET_TOKEN_LIST
 * <tag_info_list>: at OFFSET_TAG_LIST_AUTH_LIST or OFFSET_TAG_LIST_AUTH_CACHE
 *
 * <header>: {<file_version><list_version><token_count>}<crc_header>
 * <token_list>: <id_token_0>...<id_token_MAX>
 * <tag_info_list>: {<tag_info_0><crc_authorization_data_0><written_date_0>}...{<tag_info_0><crc_authorization_data_0><written_date_0>}
 *
 * <*_version>: <int>
 * <token_count>: <size_t>
 * <id_token_*>: <char[21]>
 * <tag_info_*>: {<exiry_date_*><id_token_parent_0><status_*>}
 * <expiry_date_*>: <time_t>
 * <status_*>: uint8_t
 * <crc_*><uint32_t>
 *
 * Note:
 * All _MAX refers to CONFIG_OCPP_LOCAL_AUTH_LIST_MAX_LENGTH for authorization list and
 * CONFIG_OCPP_AUTH_CACHE_MAX_LENGTH for authorization cache.
 * The crc_authorization_data_* is generated by the ocpp_authorization_data structure
 * containing the token and tag info with parent id.
 * list_version is only relevant for authorization list and not authorization cache. The
 * authorization cache should have version INT_MAX.
 */

static bool filesystem_is_ready(){
	if(file_lock == NULL){
		ESP_LOGE(TAG, "File lock was not initialized");
		return false;
	}

	struct stat st;
	if(stat(DIRECTORY_PATH, &st) != 0){
		ESP_LOGE(TAG, "Directory does not exist");
		return false;
	}

	return true;
}

struct auth_cb_data{
	char id_token[21];
	authorize_cb on_accept;
	authorize_cb on_deny;
};

esp_err_t read_auth_data(struct ocpp_authorization_data * authorization_data, bool is_list){

	if(authorization_data->id_tag[0] == '\0'){
		ESP_LOGE(TAG, "Rejecting empty token during auth read");
		return ESP_ERR_INVALID_ARG;
	}

	if(!filesystem_is_ready()){
		ESP_LOGE(TAG, "File system is not ready for auth read");
		return ESP_ERR_INVALID_STATE;
	}

	const char * file_path = is_list ? auth_list_path : auth_cache_path;

	if(xSemaphoreTake(file_lock, pdMS_TO_TICKS(2000)) != pdTRUE){
		ESP_LOGE(TAG, "Failed to aquire lock to read '%s'", file_path);
		return ESP_ERR_TIMEOUT;
	}

	esp_err_t err = ESP_FAIL;
	FILE * fp = NULL;

	struct stat st;
	if(stat(file_path, &st) != 0){
		ESP_LOGW(TAG, "No authorization data at '%s'", file_path);
		err = ESP_ERR_NOT_FOUND;
		goto cleanup;
	}

	fp = fopen(file_path, "rb");
	if(fp == NULL){
		ESP_LOGE(TAG, "Authorization data at '%s' exists but could not be opened for auth read: %s", file_path, strerror(errno));
		goto cleanup;
	}

	struct auth_header header;
	if(fread(&header, sizeof(struct auth_header), 1, fp) != 1){
		ESP_LOGE(TAG, "Unable to read header during auth read: %s", strerror(errno));
		goto cleanup;
	}

	uint32_t crc;
	if(fread(&crc, sizeof(uint32_t), 1, fp) != 1){
		ESP_LOGE(TAG, "Unable to read header crc during auth read: %s", strerror(errno));
		goto cleanup;
	}

	if(esp_crc32_le(0, (uint8_t *)&header, sizeof(struct auth_header)) != crc){
		ESP_LOGE(TAG, "CRC mismatch for header during auth read");
		err = ESP_ERR_INVALID_CRC;
		goto cleanup;
	}

	ocpp_id_token id_tag;
	size_t entry_nr = 0;
	bool found = false;
	size_t read_count = 0;

	for(;read_count < header.token_count; entry_nr++){

		if(fread(&id_tag, sizeof(ocpp_id_token), 1, fp) != 1){
			ESP_LOGE(TAG, "Unable to read id token during auth read: %s", strerror(errno));
			goto cleanup;
		}

		if(id_tag[0] == '\0'){
			continue;

		}else{
			read_count++;

			if(strcmp(id_tag, authorization_data->id_tag) == 0){
				ESP_LOGI(TAG, "Found requested token for auth read");
				found = true;
				break;
			}
		}
	}

	if(!found){
		ESP_LOGW(TAG, "No id token on file matches requested token");
		err = ESP_ERR_NOT_FOUND;
		goto cleanup;
	}

	const long offset_tag_list = is_list ? OFFSET_TAG_LIST_AUTH_LIST : OFFSET_TAG_LIST_AUTH_CACHE;

	if(fseek(fp, offset_tag_list + (entry_nr * sizeof(struct auth_tag_entry)), SEEK_SET) != 0){
		ESP_LOGE(TAG, "Unable to seek to tag list of found token during auth read: %s", strerror(errno));
		goto cleanup;
	}

	struct auth_tag_entry auth_tag_info = {0};
	if(fread(&auth_tag_info, sizeof(struct auth_tag_entry), 1, fp) != 1){
		ESP_LOGE(TAG, "Unable to read tag info during auth read: %s", strerror(errno));
		err = ESP_FAIL;
		goto cleanup;
	}

	struct auth_crc_content  crc_buffer = {0};

	strncpy(crc_buffer.id_tag, id_tag, strlen(id_tag));
	memcpy(&crc_buffer.id_tag_info, &auth_tag_info.id_tag_info, sizeof(struct auth_tag_info));

	uint32_t crc_calc = esp_crc32_le(0, (uint8_t *)&crc_buffer, sizeof(struct auth_crc_content));
	if(crc_calc != auth_tag_info.crc_tag){
		ESP_LOGE(TAG, "CRC mismatch during auth read. expected %u got %u", auth_tag_info.crc_tag, crc_calc);
		err = ESP_ERR_INVALID_CRC;
		goto cleanup;
	}

	authorization_data->id_tag_info = malloc(sizeof(struct ocpp_id_tag_info));
	if(authorization_data->id_tag_info == NULL){
		ESP_LOGE(TAG, "Unable to allocate memory for read tag during auth read");
		err = ESP_ERR_NO_MEM;
		goto cleanup;
	}

	authorization_data->id_tag_info->expiry_date = auth_tag_info.id_tag_info.expiry_date;
	authorization_data->id_tag_info->status = (enum ocpp_authorization_status_id)auth_tag_info.id_tag_info.status;
	if(auth_tag_info.id_tag_info.parent_tag[0] != '\0'){
		authorization_data->id_tag_info->parent_id_tag = strdup(auth_tag_info.id_tag_info.parent_tag);
		if(authorization_data->id_tag_info->parent_id_tag == NULL){
			ESP_LOGE(TAG, "Unable to allocate memory for parent tag during auth read");
			err = ESP_ERR_NO_MEM;
			goto cleanup;
		}
	}else{
		authorization_data->id_tag_info->parent_id_tag = NULL;
	}

	err = ESP_OK;

cleanup:
	if(fp != NULL)
		fclose(fp);

	xSemaphoreGive(file_lock);
	return err;
}

enum ocpp_authorization_status_id ocpp_get_status_from_id_tag_info(struct ocpp_id_tag_info * id_tag_info){
	if(id_tag_info->status != eOCPP_AUTHORIZATION_STATUS_ACCEPTED){
		return id_tag_info->status;
	}else{
		if(id_tag_info->expiry_date == (time_t)-1 || id_tag_info->expiry_date > time(NULL)){
			return eOCPP_AUTHORIZATION_STATUS_ACCEPTED;
		}else{
			return eOCPP_AUTHORIZATION_STATUS_EXPIRED;
		}
	}
}

static void authorize_response_cb(const char * unique_id, cJSON * payload, void * cb_data){
	ESP_LOGI(TAG, "Got auth response");

	struct auth_cb_data * data = (struct auth_cb_data *)cb_data;

	if(cJSON_HasObjectItem(payload, "idTagInfo")){
		char error_str[64];
		struct ocpp_id_tag_info id_tag_info = {0};
		if(id_tag_info_from_json(cJSON_GetObjectItem(payload, "idTagInfo"), &id_tag_info, error_str, sizeof(error_str))
			!= eOCPPJ_NO_ERROR){
			ESP_LOGE(TAG, "Received idTagInfo is invalid: %s", error_str);

		}else{
			ocpp_on_id_tag_info_recieved(data->id_token, &id_tag_info);

			enum ocpp_authorization_status_id status = ocpp_get_status_from_id_tag_info(&id_tag_info);
			if(status == eOCPP_AUTHORIZATION_STATUS_ACCEPTED){
				ESP_LOGI(TAG, "Authorization status accepted");
				data->on_accept(data->id_token);
				free(cb_data);
				return;

			}else{
				ESP_LOGW(TAG, "Authorization status is %s", ocpp_authorization_status_from_id(status));
			}
		}
	}else{
		ESP_LOGE(TAG, "Authorize response lacks required 'idTagInfo'");
	}

	data->on_deny(data->id_token);
	free(cb_data);
}

static void authorize_error_cb(const char * unique_id, const char * error_code, const char * error_description, cJSON * error_details, void * cb_data){
	error_logger(unique_id, error_code, error_description, error_details, "Authorize");

	struct auth_cb_data * data = (struct auth_cb_data *)cb_data;
	if(cb_data != NULL){
		data->on_deny(data->id_token);
	}else{
		ESP_LOGE(TAG, "Authorization error cb has no callback data, unable to deny authorization");
	}

	free(cb_data);
}

void ocpp_read_local(struct ocpp_authorization_data * auth_data){
	if((ocpp_is_connected() && local_pre_authorize) || (authorize_offline && !ocpp_is_connected())){

		if(auth_list_enabled){
			ESP_LOGI(TAG, "Attempting local authorization with Local Authorization List");
			read_auth_data(auth_data, true);
		}

		if(auth_data->id_tag_info == NULL && auth_cache_enabled){
			ESP_LOGI(TAG, "Attempting local authorization auth Authorization cache");
			read_auth_data(auth_data, false);
		}
	}
}

void ocpp_authorize(const char * id_token, authorize_cb on_accept, authorize_cb on_deny){

	struct ocpp_authorization_data auth_data = {0};
	strcpy(auth_data.id_tag, id_token);

	ocpp_read_local(&auth_data);

	if((auth_data.id_tag_info == NULL && allow_offline_for_unknown && !ocpp_is_connected())
		|| (auth_data.id_tag_info != NULL && ocpp_get_status_from_id_tag_info(auth_data.id_tag_info) == eOCPP_AUTHORIZATION_STATUS_ACCEPTED)){

		on_accept(id_token);

	}else{

		if(auth_data.id_tag_info != NULL){
			ESP_LOGW(TAG, "Local authorization not accepted: %s", ocpp_authorization_status_from_id(ocpp_get_status_from_id_tag_info(auth_data.id_tag_info)));
		}

		if(!ocpp_is_connected()){
			on_deny(id_token);
		}else{

			ESP_LOGI(TAG, "Authenticating with central system");

			struct auth_cb_data * cb_data = malloc(sizeof(struct auth_cb_data));
			if(cb_data == NULL){
				ESP_LOGE(TAG, "Unable to allocate memory for callback data");
				on_deny(id_token);
			}else{

				strcpy(cb_data->id_token, id_token);
				cb_data->on_accept = on_accept;
				cb_data->on_deny = on_deny;

				cJSON * authorization = ocpp_create_authorize_request(id_token);
				if(authorization == NULL){
					ESP_LOGE(TAG, "Unable to create authorization request");
					free(cb_data);
					on_deny(id_token);
				}else{
					int err = enqueue_call(authorization, authorize_response_cb, authorize_error_cb, cb_data, eOCPP_CALL_GENERIC);
					if(err != 0){
						ESP_LOGE(TAG, "Unable to enqueue authorization request");
						cJSON_Delete(authorization);
						free(cb_data);
						on_deny(id_token);
					}
				}
			}
		}
	}

	if(auth_data.id_tag_info != NULL){
		free(auth_data.id_tag_info->parent_id_tag);
		free(auth_data.id_tag_info);
	}
}

enum id_tag_origin{
	eORIGIN_UNKNOWN = 0,
	eORIGIN_LOCAL,
	eORIGIN_CS
};

struct comparison_data{
	struct ocpp_authorization_data auth_data_1;
	ocpp_id_token original_parent_1;
	enum id_tag_origin origin_1;
	struct ocpp_authorization_data auth_data_2;
	enum id_tag_origin origin_2;
	ocpp_id_token original_parent_2;
	authorize_compare_cb on_similar;
	authorize_compare_cb on_different;
};

static void authorize_compare_parents(struct comparison_data * cmp_data);


bool is_1 = true;

static void authorize_compare_response_cb(const char * unique_id, cJSON * payload, void * cb_data){
	ESP_LOGI(TAG, "Authorize compare parent confirmation from CS");

	struct ocpp_id_tag_info * new_id_tag = malloc(sizeof(struct ocpp_id_tag_info));
	struct comparison_data * cmp_data = cb_data;

	if(new_id_tag == NULL){
		ESP_LOGE(TAG, "Unable to allocate new id tag info for comparison response");
	}else{
		new_id_tag->parent_id_tag = NULL;
		if(cJSON_HasObjectItem(payload, "idTagInfo")){
			char error_str[64];
			if(id_tag_info_from_json(cJSON_GetObjectItem(payload, "idTagInfo"), new_id_tag, error_str, sizeof(error_str))
				!= eOCPPJ_NO_ERROR){
				ESP_LOGE(TAG, "Received idTagInfo is invalid: %s", error_str);
			}else{
				if(is_1){
					ocpp_on_id_tag_info_recieved(cmp_data->auth_data_1.id_tag, new_id_tag);
					cmp_data->auth_data_1.id_tag_info = new_id_tag;
				}else{
					ocpp_on_id_tag_info_recieved(cmp_data->auth_data_2.id_tag, new_id_tag);
					cmp_data->auth_data_2.id_tag_info = new_id_tag;
				}
			}
		}
	}
	authorize_compare_parents(cmp_data);
}

static void authorize_compare_error_cb(const char * unique_id, const char * error_code, const char * error_description, cJSON * error_details, void * cb_data){
	error_logger(unique_id, error_code, error_description, error_details, "Authorize parent");

	authorize_compare_parents(cb_data);
}

static void authorize_compare_parents(struct comparison_data * cmp_data){

	struct ocpp_authorization_data * update_reference = NULL;
	enum id_tag_origin * update_reference_origin = NULL;

	bool accepted = false;
	bool possible = cmp_data != NULL;

	while(possible){
		if(cmp_data->original_parent_1[0] == '\0'
			&& (cmp_data->auth_data_1.id_tag_info == NULL || cmp_data->auth_data_1.id_tag_info->parent_id_tag == NULL)){

			update_reference = &cmp_data->auth_data_1;
			update_reference_origin = &cmp_data->origin_1;

			is_1 = true;
		}

		if(update_reference == NULL
			&& (cmp_data->original_parent_2[0] == '\0'
				&& (cmp_data->auth_data_2.id_tag_info == NULL || cmp_data->auth_data_2.id_tag_info->parent_id_tag == NULL))){

			update_reference = &cmp_data->auth_data_2;
			update_reference_origin = &cmp_data->origin_2;

			is_1 = false;
		}

		if(update_reference  == NULL){

			if(cmp_data->original_parent_1[0] != '\0'){

				if(cmp_data->original_parent_2[0] != '\0' && strcmp(cmp_data->original_parent_1, cmp_data->original_parent_2) == 0){
					accepted = true;
					break;
				}

				if(cmp_data->auth_data_2.id_tag_info != NULL && cmp_data->auth_data_2.id_tag_info->parent_id_tag != NULL
					&& strcmp(cmp_data->original_parent_1, cmp_data->auth_data_2.id_tag_info->parent_id_tag) == 0){
					accepted = true;
					break;
				}
			}

			if(cmp_data->auth_data_1.id_tag_info != NULL && cmp_data->auth_data_1.id_tag_info->parent_id_tag != NULL){

				if(cmp_data->original_parent_2[0] != '\0' && strcmp(cmp_data->auth_data_1.id_tag_info->parent_id_tag, cmp_data->original_parent_2) == 0){
					accepted = true;
					break;
				}

				if(cmp_data->auth_data_2.id_tag_info != NULL && cmp_data->auth_data_2.id_tag_info->parent_id_tag != NULL
					&& strcmp(cmp_data->auth_data_1.id_tag_info->parent_id_tag, cmp_data->auth_data_2.id_tag_info->parent_id_tag) == 0){
					accepted = true;
					break;
				}

			}

			if(cmp_data->origin_1 <= cmp_data->origin_2){
				update_reference = &cmp_data->auth_data_1;
				update_reference_origin = &cmp_data->origin_1;

				is_1 = true;
			}else{
				update_reference = &cmp_data->auth_data_2;
				update_reference_origin = &cmp_data->origin_2;

				is_1 = false;
			}

			free_id_tag_info(update_reference->id_tag_info);
			update_reference->id_tag_info = NULL;
		}

		cJSON * authorization = NULL;
		switch(*update_reference_origin){
		case eORIGIN_UNKNOWN:
			ocpp_read_local(update_reference);
			*update_reference_origin = eORIGIN_LOCAL;
			break;
		case eORIGIN_LOCAL:
			authorization = ocpp_create_authorize_request(update_reference->id_tag);
			*update_reference_origin = eORIGIN_CS;

			if(authorization == NULL){
				ESP_LOGE(TAG, "Unable to create authorization request during comparison");
			}else{
				int err = enqueue_call(authorization, authorize_compare_response_cb, authorize_compare_error_cb, cmp_data, eOCPP_CALL_GENERIC);
				if(err != 0){
					ESP_LOGE(TAG, "Unable to enqueue authorization request during comparison");
					cJSON_Delete(authorization);
					authorization = NULL;
				}
			}
			break;
		case eORIGIN_CS:
			possible = false;
			break;
		}

		if(authorization != NULL)
			break;
	}

	if(accepted || !possible){
		if(accepted){
			cmp_data->on_similar(cmp_data->auth_data_1.id_tag, cmp_data->auth_data_2.id_tag);
		}else{
			cmp_data->on_different(cmp_data->auth_data_1.id_tag, cmp_data->auth_data_2.id_tag);
		}

		free_id_tag_info(cmp_data->auth_data_1.id_tag_info);
		free_id_tag_info(cmp_data->auth_data_2.id_tag_info);
		free(cmp_data);
	}
}

void ocpp_authorize_compare(const char * id_token_1, const char * parent_token_1, const char * id_token_2, const char * parent_token_2,
			authorize_compare_cb on_similar, authorize_compare_cb on_different){

	ESP_LOGI(TAG, "Comparing tokens");

	if(strcasecmp(id_token_1, id_token_2) == 0
		|| (parent_token_1 != NULL && parent_token_2 != NULL && strcmp(parent_token_1, parent_token_2) == 0)){

		on_similar(id_token_1, id_token_2);
		return;
	}

	struct comparison_data * cmp_data = calloc(sizeof(struct comparison_data), 1);
	if(cmp_data == NULL){
		ESP_LOGE(TAG, "Unable to allocate comparison data");
		on_different(id_token_1, id_token_2);
	}

	cmp_data->on_similar = on_similar;
	cmp_data->on_different = on_different;

	strcpy(cmp_data->auth_data_1.id_tag, id_token_1);
	strcpy(cmp_data->auth_data_2.id_tag, id_token_2);

	if(parent_token_1 != NULL)
		strcpy(cmp_data->original_parent_1, parent_token_1);

	if(parent_token_2 != NULL)
		strcpy(cmp_data->original_parent_2, parent_token_2);

	authorize_compare_parents(cmp_data);
}

int write_auth_tag_entry(ocpp_id_token id_tag, struct ocpp_id_tag_info * id_tag_info, time_t written_timestamp, FILE * fp){
	struct auth_tag_entry tag_entry = {0};
	if(id_tag_info != NULL){
		struct auth_tag_info auth_tag = {0};

		auth_tag.expiry_date = id_tag_info->expiry_date;
		auth_tag.status = (uint8_t)id_tag_info->status;
		memset(auth_tag.parent_tag, 0, sizeof(ocpp_id_token));

		if(id_tag_info->parent_id_tag != NULL){
			strcpy(auth_tag.parent_tag, id_tag_info->parent_id_tag);
		}

		struct auth_crc_content crc_buffer = {0};
		strcpy(crc_buffer.id_tag, id_tag);
		memcpy(&crc_buffer.id_tag_info, &auth_tag, sizeof(struct auth_tag_info));

		memcpy(&tag_entry.id_tag_info, &auth_tag, sizeof(struct auth_tag_info));
		tag_entry.crc_tag = esp_crc32_le(0, (uint8_t *)&crc_buffer, sizeof(struct auth_crc_content));
		tag_entry.written_timestamp = written_timestamp;
	}

	if(fwrite(&tag_entry, sizeof(struct auth_tag_entry), 1, fp) != 1){
		ESP_LOGE(TAG, "Unable to write id_tag nr to file during full update");
		return -1;
	}

	return 0;
}

enum ocpp_update_status_id update_auth_full(int version, struct ocpp_authorization_data * auth_data, size_t list_length){

	ESP_LOGI(TAG, "Updating auth list (full)");
	if(xSemaphoreTake(file_lock, pdMS_TO_TICKS(2000)) != pdTRUE){
		ESP_LOGE(TAG, "Full Update failed: Mutex not aquired");
		return eOCPP_UPDATE_STATUS_FAILED;
	}

	if(auth_data == NULL){
		ESP_LOGI(TAG, "Update auth list full without auth_data, authorization list will be removed");
		struct stat st;
		enum ocpp_update_status_id result;
		if(stat(auth_list_path, &st) != 0){
			ESP_LOGI(TAG, "Could not find any auth list on file. Deletion is unnecessary");
			result = eOCPP_UPDATE_STATUS_ACCEPTED;
		}else{
			if(remove(auth_list_path) != 0){
				ESP_LOGE(TAG, "Unable to remove auth list: %s", strerror(errno));
				result = eOCPP_UPDATE_STATUS_FAILED;
			}else{
				result = eOCPP_UPDATE_STATUS_ACCEPTED;
			}
		}

		xSemaphoreGive(file_lock);
		return result;
	}

	FILE * fp = fopen(auth_list_tmp_path, "wb");
	if(fp == NULL){
		ESP_LOGE(TAG, "Unable to create temporary path for full list update");
		goto error;
	}

	struct auth_header header = {
		.file_version = 1,
		.list_version = version,
		.token_count = list_length
	};

	if(fwrite(&header, sizeof(struct auth_header), 1, fp) != 1){
		ESP_LOGE(TAG, "Unable to write header during full update");
		goto error;
	}

	uint32_t crc = esp_crc32_le(0, (uint8_t *)&header, sizeof(struct auth_header));
	if(fwrite(&crc, sizeof(uint32_t), 1, fp) != 1){
		ESP_LOGE(TAG, "Unable to write header crc during full update");
		goto error;
	}

	for(size_t i = 0; i < list_length; i++){
		if(fwrite(&auth_data[i].id_tag, sizeof(ocpp_id_token), 1, fp) != 1){
			ESP_LOGE(TAG, "Unable to write id_tag nr %d to file during full update", i);
			goto error;
		}
	}

	const long offset_tag_list = OFFSET_TAG_LIST_AUTH_LIST;
	if(fseek(fp, offset_tag_list, SEEK_SET) != 0){
		ESP_LOGE(TAG, "Unable to seek to tag info section during full update");
		goto error;
	}

	time_t written_timestamp = time(NULL);

	for(size_t i = 0; i < list_length; i++){
		if(auth_data[i].id_tag_info == NULL){
			ESP_LOGE(TAG, "Authorization data %ul has not id_tag_info required during full update", i);
			goto error;
		}

		if(write_auth_tag_entry(auth_data[i].id_tag, auth_data[i].id_tag_info, written_timestamp, fp) != 0)
			goto error;
	}

	struct stat st;
	if(stat(auth_list_path, &st) == 0)
		remove(auth_list_path);

	fclose(fp);
	fp = NULL;

	if(rename(auth_list_tmp_path, auth_list_path) != 0){
		ESP_LOGE(TAG, "Unable to rename temporary file during full update: %s", strerror(errno));
		goto error;
	}

	xSemaphoreGive(file_lock);

	return eOCPP_UPDATE_STATUS_ACCEPTED;

error:
	if(fp != NULL){
		fclose(fp);
		remove(auth_list_tmp_path);
	}
	xSemaphoreGive(file_lock);

	return eOCPP_UPDATE_STATUS_FAILED;
}

enum ocpp_update_status_id update_auth_differential(int version, struct ocpp_authorization_data * auth_data, bool is_list,  size_t list_length, size_t * length_out){
	ESP_LOGI(TAG, "Differential update of %s", is_list ? "Authorization list" : "Authorization cache");

	if(list_length == 0){
		ESP_LOGW(TAG, "No entries in list during differential update. No changes will be made");
		return eOCPP_UPDATE_STATUS_ACCEPTED;
	}

	enum ocpp_update_status_id ret = eOCPP_UPDATE_STATUS_FAILED;

	if(xSemaphoreTake(file_lock, pdMS_TO_TICKS(2000)) != pdTRUE){
		ESP_LOGE(TAG, "Differential Update failed: Mutex not aquired");
		return eOCPP_UPDATE_STATUS_FAILED;
	}

	const char * auth_path = is_list ? auth_list_path : auth_cache_path;
	const size_t max_entries = is_list ? CONFIG_OCPP_LOCAL_AUTH_LIST_MAX_LENGTH : CONFIG_OCPP_AUTH_CACHE_MAX_LENGTH;

	long * output_entry = NULL; // Array where at a given index will contain the auth file entry index for the same auth_data index
	FILE * fp;

	struct auth_header header;
	struct stat st;
	if(stat(auth_path, &st) != 0){
		ESP_LOGW(TAG, "Differential update requested for empty auth at '%s', creating new auth file", auth_path);

		fp = fopen(auth_path, "w+b");
		if(fp == NULL){
			ESP_LOGE(TAG, "Unable to create differential update");
			goto cleanup;
		}

		header.file_version = 1;
		header.list_version = is_list ? 0 : INT_MAX;
		header.token_count = 0;

		if(fseek(fp, OFFSET_TOKEN_LIST, SEEK_SET) != 0){
			ESP_LOGE(TAG, "Unable to seek to token list during differential update: %s", strerror(errno));
			goto cleanup;
		}

	}else{
		fp = fopen(auth_path, "r+b");
		if(fp == NULL){
			ESP_LOGE(TAG, "Unable to create differential update");
			goto cleanup;
		}

		if(fread(&header, sizeof(struct auth_header), 1, fp) != 1){
			ESP_LOGE(TAG, "Unable to read header during differential update: %s", strerror(errno));
			goto cleanup;
		}

		uint32_t crc;
		if(fread(&crc, sizeof(uint32_t), 1, fp) != 1){
			ESP_LOGE(TAG, "Unable to read header crc during differential update: %s", strerror(errno));
			goto cleanup;
		}

		if(esp_crc32_le(0, (uint8_t *)&header, sizeof(struct auth_header)) != crc){
			ESP_LOGE(TAG, "CRC mismatch for header during differential update: %s", strerror(errno));
			goto cleanup;
		}

	}

	ESP_LOGI(TAG, "Current auth file header: file version: %d, list version: %d, token count: %ul", header.file_version, header.list_version, header.token_count);

	if(header.list_version >= version && header.list_version != INT_MAX){
		ESP_LOGW(TAG, "Requested update to old/current list version during differential update");
		ret = eOCPP_UPDATE_STATUS_VERSION_MISMATCH;
		goto cleanup;
	}

	output_entry = malloc(sizeof(long) * list_length);
	if(output_entry == NULL){
		ESP_LOGE(TAG, "Unable to allocate buffer to track written items during differential update");
		goto cleanup;
	}

	for(size_t i = 0; i < list_length; i++){
		output_entry[i] = -1; // Set to invalid offset to indicate 'not set'
	}
	size_t match_count = 0;

	size_t * known_vacant_entries = malloc(sizeof(size_t) * list_length);
	size_t known_vacant_count = 0;

	ocpp_id_token id_tag;

	size_t local_entry_nr = 0;
	size_t read_count = 0;

	// Find all entries that have an existing entry on file and vacant entries
	for(;read_count < header.token_count && match_count < list_length; local_entry_nr++){

		if(fread(&id_tag, sizeof(ocpp_id_token), 1, fp) != 1){
			ESP_LOGE(TAG, "Unable to read id tag at %ul during differential update: %s", local_entry_nr, strerror(errno));
			free(known_vacant_entries);
			goto cleanup;
		}

		if(id_tag[0] == '\0'){
			if(known_vacant_count < list_length){
				known_vacant_entries[known_vacant_count++] = local_entry_nr;
			}
			continue;
		}else{
			read_count++;
			for(size_t i = 0; i < list_length; i++){
				if(strcmp(id_tag, auth_data[i].id_tag) == 0){
					ESP_LOGI(TAG, "Differential update entry is on file: %s", id_tag);
					output_entry[i] = local_entry_nr;
					match_count++;
					break;
				}
			}
		}
	}

	if(match_count < list_length){ // If a tag is not on file, then it needs to be allocated an entry on file

		size_t known_vacant_index = 0;
		size_t i = 0;
		for(size_t missing_entry_count = list_length - match_count; missing_entry_count > 0; missing_entry_count--){
			for(; i < list_length; i++){
				if(output_entry[i] == -1)
					break;
			}

			if(auth_data[i].id_tag_info == NULL){ // if requested to delete an entry that does not exist

				output_entry[i] = -2; // indicate 'should not do anything'
				match_count++; // We matched NULL tag with no entry on file
			}else{
				bool found = false;
				for(size_t j = 0; j < list_length; j++){ // If an other entry will be deleted, use that entry istead of new entry
					if(output_entry[j] > 0 && auth_data[j].id_tag_info == NULL){
						output_entry[i] = output_entry[j];
						output_entry[j] = -2;

						match_count++; // We matched new entry with recently vacant entry
						found = true;
						break;
					}
				}

				// If an entry on file has been deleted by previous update request, use that entry to prevent large gaps on file
				if(!found && known_vacant_index < known_vacant_count){
					output_entry[i] = known_vacant_entries[known_vacant_index++];
					match_count++;
					header.token_count++;

				}else if(local_entry_nr < max_entries){ // Else we use a new enty at the end of the list
					output_entry[i] = local_entry_nr;
					local_entry_nr++;
					match_count++;
					header.token_count++;
				}
			}
		}
	}
	free(known_vacant_entries);

	if(match_count < list_length){
		ESP_LOGE(TAG, "Unable to find vacant entries for all tags during differential update");
		*length_out = header.token_count + match_count + list_length;
		goto cleanup;
	}

	ocpp_id_token delete_token = {0};

	for(size_t i = 0; i < list_length; i++){
		if(output_entry[i] < 0) // Skip deletion of non existing token or replaced token
			continue;

		if(fseek(fp, OFFSET_TOKEN_LIST + (sizeof(ocpp_id_token) * output_entry[i]), SEEK_SET) != 0){
			ESP_LOGE(TAG, "Unable to seek for replacing token list entry during differential update");
			goto cleanup;
		}

		if(auth_data[i].id_tag_info == NULL){
			if(fwrite(delete_token, sizeof(ocpp_id_token), 1, fp) != 1){
				ESP_LOGE(TAG, "Unable to delete token during differential update");
			}
			header.token_count--;
		}else{
			if(fwrite(&auth_data[i].id_tag, sizeof(ocpp_id_token), 1, fp) != 1){
				ESP_LOGE(TAG, "Unable to write id_tag nr %d to file during differential update", i);
				goto cleanup;
			}
		}
	}

	const long tag_list_offset = is_list ? OFFSET_TAG_LIST_AUTH_LIST : OFFSET_TAG_LIST_AUTH_CACHE;
	time_t written_timestamp = time(NULL);

	for(size_t i = 0; i < list_length; i++){
		if(output_entry[i] < 0)
			continue;

		if(fseek(fp, tag_list_offset + (sizeof(struct auth_tag_entry) * output_entry[i]), SEEK_SET) != 0){
			ESP_LOGE(TAG, "Unable to seek for replacing tag list entry during differential update");
			goto cleanup;
		}

		ESP_LOGI(TAG, "writing to %ld", output_entry[i]);
		if(write_auth_tag_entry(auth_data[i].id_tag, auth_data[i].id_tag_info, written_timestamp, fp) != 0)
			goto cleanup;
	}

	*length_out = header.token_count;

	if(fseek(fp, OFFSET_HEADER, SEEK_SET) != 0){
		ESP_LOGE(TAG, "Unable to seek back to replacing header during differential update");
		goto cleanup;
	}

	if(fwrite(&header, sizeof(struct auth_header), 1, fp) != 1){
		ESP_LOGE(TAG, "Unable to write auth header during differential update");
		goto cleanup;
	}

	uint32_t crc = esp_crc32_le(0, (uint8_t *)&header, sizeof(struct auth_header));
	if(fwrite(&crc, sizeof(uint32_t), 1, fp) != 1){
		ESP_LOGE(TAG, "Unable to write header crc during differential update");
		goto cleanup;
	}

	ret = eOCPP_UPDATE_STATUS_ACCEPTED;

cleanup:
	free(output_entry);

	if(fp != NULL){
		if(ferror(fp)){
			ESP_LOGE(TAG, "Ferror set during differential update cleanup. errno set to: %s", strerror(errno));
		}
		fclose(fp);
	}
	xSemaphoreGive(file_lock);

	return ret;
}

enum ocpp_update_status_id ocpp_update_auth_list(int version, bool update_full, struct ocpp_authorization_data * auth_data, size_t list_length){

	if(version == -1 || version == 0){
		ESP_LOGW(TAG, "Rejecting auth list update due to list version being prohibited by ocpp 1.6 errata version 4");
		return eOCPP_UPDATE_STATUS_FAILED;
	}

	if(!filesystem_is_ready()){
		ESP_LOGE(TAG, "Filesystem is not ready for full authorization list update");
		return eOCPP_UPDATE_STATUS_FAILED;
	}

	ESP_LOGI(TAG, "Filesystem ready, stating update");

	if(update_full){
		return update_auth_full(version, auth_data, list_length);
	}else{

		int current_version = ocpp_get_auth_list_version();
		if(current_version == -1){
			return eOCPP_UPDATE_STATUS_FAILED;

		}else if(current_version <= version){
			return eOCPP_UPDATE_STATUS_VERSION_MISMATCH;

		}else{
			size_t result_length = 0;
			enum ocpp_update_status_id result = update_auth_differential(version, auth_data, true, list_length, &result_length);
			ESP_LOGI(TAG, "Differential update exited with status %s and length %ul", ocpp_update_status_from_id(result), result_length);

			return result;
		}
	}
}

size_t auth_cache_remove(int requested_remove_count){
	ESP_LOGI(TAG, "Removing from cache");
	size_t ret = -1;

	if(!filesystem_is_ready()){
		ESP_LOGE(TAG, "File system is not ready for removing tokens from auth chache");
		return ret;
	}

	if(xSemaphoreTake(file_lock, pdMS_TO_TICKS(2000)) != pdTRUE){
		ESP_LOGE(TAG, "Failed to aquire lock to remove tokens from auth cache");
		return ret;
	}

	struct stat st;
	if(stat(auth_cache_path, &st) != 0){
		ESP_LOGW(TAG, "No authorization cache");
		xSemaphoreGive(ret);

		return 0;
	}

	FILE * fp = fopen(auth_cache_path, "r+b");
	if(fp == NULL){
		ESP_LOGE(TAG, "Authorization cache exists but could not be opened for removing tokens: %s", strerror(errno));
		goto cleanup;
	}

	struct auth_header header;
	if(fread(&header, sizeof(struct auth_header), 1, fp) != 1){
		ESP_LOGE(TAG, "Unable to read header during removal of tokens from auth cache: %s", strerror(errno));
		goto cleanup;
	}

	uint32_t crc;
	if(fread(&crc, sizeof(uint32_t), 1, fp) != 1){
		ESP_LOGE(TAG, "Unable to read header crc during removal of tokens from auth cache: %s", strerror(errno));
		goto cleanup;
	}

	if(esp_crc32_le(0, (uint8_t *)&header, sizeof(struct auth_header)) != crc){
		ESP_LOGE(TAG, "CRC mismatch for header during removal of tokens from auth cache");
		goto cleanup;
	}

	if(fseek(fp, OFFSET_TAG_LIST_AUTH_CACHE, SEEK_SET) != 0){
		ESP_LOGE(TAG, "Unable to seek to tag list during removal of tokens from auth cache: %s", strerror(errno));
		goto cleanup;
	}

	size_t * remove_index = malloc(sizeof(size_t) * header.token_count);
	size_t remove_count = 0;

	if(remove_index == NULL){
		ESP_LOGE(TAG, "Unable to allocate memory for removed indexes");
		goto cleanup;
	}

	struct auth_tag_entry entry;
	size_t read_count = 0;

	time_t now = time(NULL);

	struct auth_tag_entry null_entry = {0};
	for(size_t local_entry_nr = 0; read_count < header.token_count; local_entry_nr++){
		if(fread(&entry, sizeof(struct auth_tag_entry), 1, fp) != 1){
			ESP_LOGE(TAG, "Unable to read id tag at %ul during differential update: %s", local_entry_nr, strerror(errno));
			free(remove_index);
			goto cleanup;
		}

		if(memcmp(&entry, &null_entry, sizeof(struct auth_tag_entry)) == 0)
			continue;

		read_count++;

		if(entry.id_tag_info.expiry_date < now
			|| entry.id_tag_info.status != (uint8_t)eOCPP_AUTHORIZATION_STATUS_ACCEPTED
			){
			ESP_LOGI(TAG, "Marking index for deletion due to invalidity %ul", local_entry_nr);
			remove_index[remove_count++] = local_entry_nr;
		}
	}

	struct timestamped_entry{
		size_t entry;
		time_t timestamp;
	};

	if(remove_count < requested_remove_count){
		size_t remaining = requested_remove_count - remove_count;

		struct timestamped_entry * oldest_entries = malloc(sizeof(struct timestamped_entry) * remaining);
		if(oldest_entries == NULL){
			ESP_LOGE(TAG, "Unable to allocate buffer to track oldes entries");
			free(remove_index);
			goto cleanup;
		}

		for(size_t i = 0; i < remaining; i++){
			oldest_entries[i].timestamp = LONG_MAX;
		}

		if(fseek(fp, OFFSET_TAG_LIST_AUTH_CACHE, SEEK_SET) != 0){
			ESP_LOGE(TAG, "Unable to seek back to tag list to check timestamp during removal of tokens from auth cache: %s", strerror(errno));
			goto cleanup;
		}
		read_count = 0;

		size_t skip_check_index = 0;
		for(size_t local_entry_nr = 0; read_count < header.token_count; local_entry_nr++){

			if(fread(&entry, sizeof(struct auth_tag_entry), 1, fp) != 1){
				ESP_LOGE(TAG, "Unable to read id tag at %ul during differential update: %s", local_entry_nr, strerror(errno));
				free(remove_index);
				goto cleanup;
			}

			if(skip_check_index < remove_count && remove_index[skip_check_index] == local_entry_nr){
				skip_check_index++;
				continue;
			}

			if(memcmp(&entry, &null_entry, sizeof(struct auth_tag_entry)) == 0)
				continue;

			read_count++;

			time_t new_time = entry.written_timestamp;
			size_t new_entry = local_entry_nr;

			for(size_t i = 0; i < remaining; i++){
				if(new_time < oldest_entries[i].timestamp){

					time_t tmp_time = oldest_entries[i].timestamp;
					size_t tmp_entry = oldest_entries[i].entry;

					oldest_entries[i].timestamp = new_time;
					oldest_entries[i].entry = new_entry;

					new_time = tmp_time;
					new_entry = tmp_entry;
				}
			}
		}

		for(size_t i = 0; i < remaining; i++){
			ESP_LOGI(TAG, "Marking oldest for deletion: %ul", oldest_entries[i].entry);
			remove_index[remove_count++] = oldest_entries[i].entry;
		}
	}

	ocpp_id_token delete_token = {0};
	for(size_t i = 0; i < remove_count; i++){
		if(fseek(fp, OFFSET_TOKEN_LIST + sizeof(ocpp_id_token) * remove_index[i], SEEK_SET) != 0){
			ESP_LOGE(TAG, "Unable to seek to token for deletion during removal of tokens from auth cache: %s", strerror(errno));
			free(remove_index);
			goto cleanup;
		}


		if(fwrite(&delete_token, sizeof(ocpp_id_token), 1, fp) != 1){
			ESP_LOGE(TAG, "Unable to delete token at %d during removal of tokens from auth cache: %s", remove_index[i], strerror(errno));
			free(remove_index);
			goto cleanup;
		}

		header.token_count--;
	}

	for(size_t i = 0; i < remove_count; i++){
		if(fseek(fp, OFFSET_TAG_LIST_AUTH_CACHE + sizeof(struct auth_tag_entry) * remove_index[i], SEEK_SET) != 0){
			ESP_LOGE(TAG, "Unable to seek to tag info for deletion during removal of tokens from auth cache: %s", strerror(errno));
			free(remove_index);
			goto cleanup;
		}


		if(fwrite(&null_entry, sizeof(struct auth_tag_entry), 1, fp) != 1){
			ESP_LOGE(TAG, "Unable to delete tag info at %d during removal of tokens from auth cache: %s", remove_index[i], strerror(errno));
			free(remove_index);
			goto cleanup;
		}
	}

	free(remove_index);

	if(fseek(fp, OFFSET_HEADER, SEEK_SET) != 0){
		ESP_LOGE(TAG, "Unable to seek back to header to update with new count during removal of tokens from auth cache: %s", strerror(errno));
		goto cleanup;
	}

	if(fwrite(&header, sizeof(struct auth_header), 1, fp) != 1){
		ESP_LOGE(TAG, "Unable to update header during removal of tokens from auth cache: %s", strerror(errno));
		goto cleanup;
	}

	crc = esp_crc32_le(0, (uint8_t *)&header, sizeof(struct auth_header));
	if(fwrite(&crc, sizeof(uint32_t), 1, fp) != 1){
		ESP_LOGE(TAG, "Unable to write header crc during removal of tokens from auth cache: %s", strerror(errno));
		goto cleanup;
	}

	ret = header.token_count;

cleanup:
	xSemaphoreGive(file_lock);
	fclose(fp);

	return ret;
}

void ocpp_on_id_tag_info_recieved(const char * id_token, struct ocpp_id_tag_info * id_tag_info){
	ESP_LOGI(TAG, "Recieved id tag info");

	struct ocpp_authorization_data auth_data;
	strcpy(auth_data.id_tag, id_token);

	bool in_list = false;
	if(auth_list_enabled){
		ESP_LOGI(TAG, "Checking for local authorization list mismatch");
		if(read_auth_data(&auth_data, auth_list_path) == ESP_OK){
			in_list = true;

			struct ocpp_id_tag_info * local_id_tag = auth_data.id_tag_info;

			if(id_tag_info->expiry_date == local_id_tag->expiry_date
				|| id_tag_info->status != local_id_tag->status
				|| ((id_tag_info->parent_id_tag != NULL || local_id_tag->parent_id_tag != NULL)
					&& ((id_tag_info->parent_id_tag == NULL || local_id_tag->parent_id_tag == NULL)
						|| strcmp(id_tag_info->parent_id_tag, local_id_tag->parent_id_tag) == 0))){

				ESP_LOGW(TAG, "local Authorization list mismatch");
				ocpp_send_status_notification(-1, OCPP_CP_ERROR_LOCAL_LIST_CONFLICT,
							NULL, NULL, NULL, true, false);
			}else{
				ESP_LOGI(TAG, "local Authorization list matched");
			}

			free_id_tag_info(auth_data.id_tag_info);
		}
	}

	if(auth_cache_enabled && !in_list){
		ESP_LOGI(TAG, "Adding or updating token in authorization cache");
		size_t result_length = 0;
		auth_data.id_tag_info = id_tag_info;

		enum ocpp_update_status_id result = update_auth_differential(INT_MAX, &auth_data, false, 1, &result_length);

		if(result == eOCPP_UPDATE_STATUS_FAILED && result_length > CONFIG_OCPP_AUTH_CACHE_MAX_LENGTH){
			size_t remove_count = result_length - CONFIG_OCPP_AUTH_CACHE_MAX_LENGTH;
			ESP_LOGW(TAG, "Max tokens in authorization cache. Attempting to remove %d tokens", remove_count);

			auth_cache_remove(remove_count);
			ESP_LOGI(TAG, "Removal complete. Retrying to add token");
			result = update_auth_differential(INT_MAX, &auth_data, false, 1, &result_length);
		}

		if(result != eOCPP_UPDATE_STATUS_ACCEPTED){
			ESP_LOGE(TAG, "Unable to add token to authorization cache. authorization cache will not work as expected");
			ocpp_send_status_notification(-1, OCPPJ_ERROR_INTERNAL, "Unable to update authorization cache",
						NULL, NULL, true, false);
		}
	}

	ESP_LOGI(TAG, "Recieved id tag handeling complete");
}

int ocpp_auth_clear_cache(){

	if(!filesystem_is_ready()){
		ESP_LOGE(TAG, "Filesystem is not ready for clearing auth cache");
		return -1;
	}

	struct stat st;
	if(stat(auth_cache_path, &st) != 0){
		ESP_LOGW(TAG, "No cache found when clearing cache");
		return 0;
	}

	return remove(auth_cache_path);
}

// NOTE: this will return -1 on error which ocpp will interpret as "not supported"
int ocpp_get_auth_list_version(){
	if(!filesystem_is_ready()){
		ESP_LOGE(TAG, "Filesystem is not ready for getting auth list version");
		return -1;
	}

	if(xSemaphoreTake(file_lock, pdMS_TO_TICKS(2000)) != pdTRUE){
		ESP_LOGE(TAG, "Failed to aquire lock to read list version");
		return ESP_ERR_TIMEOUT;
	}

	struct stat st;
	if(stat(auth_list_path, &st) != 0){
		ESP_LOGI(TAG, "No auth list (empty) found during get list version");
		xSemaphoreGive(file_lock);
		return 0;
	}

	FILE * fp = fopen(auth_list_path, "rb");
	if(fp == NULL){
		ESP_LOGE(TAG, "Unable to open existing auth list for getting list version");
		xSemaphoreGive(file_lock);
		return -1;
	}

	int ret = -1;

	struct auth_header header;
	if(fread(&header, sizeof(struct auth_header), 1, fp) != 1){
		ESP_LOGE(TAG, "Unable to read header when getting list version: %s", strerror(errno));
		goto cleanup;
	}

	uint32_t crc;
	if(fread(&crc, sizeof(uint32_t), 1, fp) != 1){
		ESP_LOGE(TAG, "Unable to read header crc when getting list version: %s", strerror(errno));
		goto cleanup;
	}

	if(esp_crc32_le(0, (uint8_t *)&header, sizeof(struct auth_header)) != crc){
		ESP_LOGE(TAG, "CRC mismatch for header when getting list version");
		goto cleanup;
	}

	ret = header.list_version;

cleanup:
	xSemaphoreGive(file_lock);
	fclose(fp);
	return ret;
}

cJSON * ocpp_auth_get_diagnostics(){

	cJSON * res = cJSON_CreateObject();
	if(res == NULL){
		ESP_LOGE(TAG, "Unable to create ocpp diagnostics for auth");
		return res;
	}

	cJSON_AddBoolToObject(res, "local_pre_authorize", local_pre_authorize);
	cJSON_AddBoolToObject(res, "authorize_offline", authorize_offline);
	cJSON_AddBoolToObject(res, "auth_list_enabled", auth_list_enabled);
	cJSON_AddBoolToObject(res, "auth_cache_enabled", auth_cache_enabled);
	cJSON_AddBoolToObject(res, "allow_offline_for_unknown", allow_offline_for_unknown);

	struct stat st;
	cJSON_AddBoolToObject(res, "cache_exists", stat(auth_list_path, &st) != 0);
	cJSON_AddBoolToObject(res, "list_exists", stat(auth_cache_path, &st) != 0);

	return res;
}

int ocpp_auth_init(){
	ESP_LOGI(TAG, "Initializing ocpp authorization");

	struct stat st;

	if(stat(CONFIG_OCPP_FILE_PATH, &st) != 0){
		ESP_LOGE(TAG, "OCPP file path ('%s') not mounted", CONFIG_OCPP_FILE_PATH);
		return -1;
	}

	file_lock = xSemaphoreCreateMutex();
	if(file_lock == NULL){
		ESP_LOGE(TAG, "Unable to create file lock");
		return -1;
	}

	if(stat(DIRECTORY_PATH, &st) != 0){
		ESP_LOGI(TAG, "Creating direcory path '%s'", DIRECTORY_PATH);
		if(mkdir(DIRECTORY_PATH, S_IRWXU | S_IRWXG) != 0){
			ESP_LOGE(TAG, "Unable to create auth directory: '%s'", strerror(errno));
			xSemaphoreGive(file_lock);
			return -1;
		}
	}else{
		ESP_LOGI(TAG, "Directory path '%s' exists", DIRECTORY_PATH);
	}

	xSemaphoreGive(file_lock);
	return 0;
}

void ocpp_auth_deinit(){
	if(file_lock != NULL){
		vSemaphoreDelete(file_lock);
		file_lock = NULL;
	}
}
