#ifndef OCPP_TASK_H
#define OCPP_TASK_H

#include <stdbool.h>

#include "esp_websocket_client.h"

#include "ocpp_call_with_cb.h"
#include "types/ocpp_registration_status.h"

#define OCPP_CALL_TIMEOUT 10000

/**
 * Determins queueing of outgoing calls and error handling in case of transactions.
 */
enum call_type{
	eOCPP_CALL_GENERIC = 1<<0,
	eOCPP_CALL_TRANSACTION_RELATED = 1<<1,
	eOCPP_CALL_BLOCKING = 1<<2,
};

/**
 * Reply to central service originated action call.
 */
int send_call_reply(cJSON * call);

/**
 * Used to send new action calls originating from the charge point once all prior calls have finished
 */
int enqueue_call(cJSON * call, ocpp_result_callback result_cb, ocpp_error_callback error_cb, void * cb_data, enum call_type type);
void block_enqueue_call(uint8_t call_type_mask);
uint8_t get_blocked_enqueue_mask();
size_t enqueued_call_count();

/**
 * Used to replace invalid id generated by CP to istead use valid id generated by CS,
 *
 * @details: This function does not replace the ids within the queue, but istead allows it to be
 * updated once the relevant transaction is dequeued or prepared to be sendt.
 */
int ocpp_update_enqueued_transaction_id(int old_id, int new_id);

/**
 * Used to set functionality that allows transactions that are older than the ones present in the queue
 * to be sendt before queue is empty. Necessary to comply with requirement of transactions being sendt in order
 * if connection to central system is lost and queue becomes full or blocked.
 *
 * @param oldest_non_enqueued_timestamp should return the timestamp of the oldest message or LONG_MAX if non can be found.
 * @param oldest_non_enqueued_message should return the call_message required to construct the ocpp_call_with_cb stuct and
 * should remove the returned call_message from 'Non enqueued messages'.
 *
 * The remaining parameters are used to populate their respective transaction related ocpp_call_with_cb.
 */
void ocpp_set_offline_functions(time_t (*oldest_non_enqueued_timestamp)(), cJSON * (*oldest_non_enqueued_message)(void ** cb_data),
				ocpp_result_callback start_transaction_result_cb, ocpp_error_callback start_transaction_error_cb, void * start_transaction_cb_data,
				ocpp_result_callback stop_transaction_result_cb, ocpp_error_callback stop_transaction_error_cb, void * stop_transaction_cb_data,
				ocpp_result_callback meter_transaction_result_cb, ocpp_error_callback meter_transaction_error_cb, void * meter_transaction_cb_data);

int start_ocpp(const char * url, const char * charger_id, uint32_t ocpp_heartbeat_interval, uint8_t ocpp_transaction_message_attempts, uint16_t ocpp_transaction_message_retry_interval);
void stop_ocpp(void);

/**
 * Get the stucture with the message that was last transmitted to the central system and expecting a reply.
 * it takes a semaphore, which is given back by calling clear_active_call or give_active_call.
 */
BaseType_t take_active_call(struct ocpp_call_with_cb ** call_data, char  ** call_id, uint timeout_ms);

/**
 * Give back active call without clearing it.
 */
BaseType_t give_active_call();

/**
 * Indicate that a reply has been recieved and handled or failed and clear stucture for next ocpp call.
 * This function is called by ocpp_listener.
 */
void clear_active_call(void);

int handle_ocpp_call(int last_listener_state);
void block_sending_call(uint8_t call_type_mask);

int complete_boot_notification_process(char * serial_nr);

int start_ocpp_heartbeat(void);
void stop_ocpp_heartbeat(void);
void update_heartbeat_timer(uint sec);

void update_transaction_message_related_config(uint8_t ocpp_transaction_message_attempts, uint16_t ocpp_transaction_message_retry_interval);

/**
 * Check if weboscket is connected to central system
 */
bool is_connected(void);
void set_connected(bool connected);

enum ocpp_registration_status get_registration_status(void);

#endif /* OCPP_TASK_H */
