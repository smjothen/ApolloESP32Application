#ifndef OCPP_TASK_H
#define OCPP_TASK_H

#include <stdbool.h>

#include "esp_websocket_client.h"

#include "ocpp_call_with_cb.h"
#include "types/ocpp_registration_status.h"
#include "types/ocpp_charge_point_status.h"

#define OCPP_CALL_TIMEOUT 10000

/**
 * Determins queueing of outgoing calls and error handling in case of transactions.
 */
enum call_type{
	eOCPP_CALL_GENERIC = 1<<0,
	eOCPP_CALL_TRANSACTION_RELATED = 1<<1,
	eOCPP_CALL_BLOCKING = 1<<2,
};

/**
 * Reply to central service originated action call.
 */
int send_call_reply(cJSON * call);

void ocpp_send_status_notification(enum ocpp_cp_status_id new_state, const char * error_code, const char * info);

/**
 * Used to send new action calls originating from the charge point once all prior calls have finished
 */
int enqueue_call(cJSON * call, ocpp_result_callback result_cb, ocpp_error_callback error_cb, void * cb_data, enum call_type type);

/**
 * Equivalent to enqueue_call, but uses a wait of '0' when waiting for semaphores or other thread synchronisation.
 * Allows enqueuing calls from rtos timers.
 */
int enqueue_call_immediate(cJSON * call, ocpp_result_callback result_cb, ocpp_error_callback error_cb, void * cb_data, enum call_type type);
void block_enqueue_call(uint8_t call_type_mask);
uint8_t get_blocked_enqueue_mask();
size_t enqueued_call_count();

/**
 * Used to replace invalid id generated by CP to istead use valid id generated by CS,
 *
 * @details: This function does not replace the ids within the queue, but istead allows it to be
 * updated once the relevant transaction is dequeued or prepared to be sendt.
 */
int ocpp_update_enqueued_transaction_id(int old_id, int new_id);

/**
 * Used to set functionality that allows transactions that are older than the ones present in the queue
 * to be sendt before queue is empty. Necessary to comply with requirement of transactions being sendt in order
 * if connection to central system is lost and queue becomes full or blocked.
 *
 * @param oldest_non_enqueued_timestamp should return the timestamp of the oldest message or LONG_MAX if non can be found.
 * @param oldest_non_enqueued_message should return the call_message required to construct the ocpp_call_with_cb stuct and
 * should remove the returned call_message from 'Non enqueued messages'.
 *
 * The remaining parameters are used to populate their respective transaction related ocpp_call_with_cb.
 */
void ocpp_set_offline_functions(time_t (*oldest_non_enqueued_timestamp)(), cJSON * (*oldest_non_enqueued_message)(void ** cb_data),
				ocpp_result_callback start_transaction_result_cb, ocpp_error_callback start_transaction_error_cb, void * start_transaction_cb_data,
				ocpp_result_callback stop_transaction_result_cb, ocpp_error_callback stop_transaction_error_cb, void * stop_transaction_cb_data,
				ocpp_result_callback meter_transaction_result_cb, ocpp_error_callback meter_transaction_error_cb, void * meter_transaction_cb_data);

int start_ocpp(const char * url, const char * charger_id, uint32_t ocpp_heartbeat_interval, uint8_t ocpp_transaction_message_attempts, uint16_t ocpp_transaction_message_retry_interval);
void stop_ocpp(void);

/**
 * We store the original timestamp and retries with the active_call. These should only be relevant for
 * failed transactions, but makes it easier to identify failed transaction during retransmit.
 */
struct ocpp_active_call{
	struct ocpp_call_with_cb * call;
	bool is_transaction_related;
	time_t timestamp;
	uint retries;
};

/**
 * Get the stucture with the message that was last transmitted to the central system and expecting a reply.
 */
BaseType_t take_active_call_if_match(struct ocpp_active_call * call, const char * unique_id, uint timeout_ms);

/**
 * Prepares the call for new attempt if it is a transaction and maximum retries has not been exceeded. Otherwise it calls the error callback.
 */
void fail_active_call(struct ocpp_active_call * call, const char * error_code, const char * error_description, cJSON * error_details);

/**
 * Sends the next message of type CALL (client-to-server) if any exists
 *
 * @return The number of messages still waiting to be sent or -1 on error.
 */
int handle_ocpp_call();
void block_sending_call(uint8_t call_type_mask);

/**
 * @brief Sets a task to be notified of ocpp_task_event using eSetBits.
 *
 * @param task the task to be notified.
 * @param offset a value used to left shift the ocpp_task_event to allow room for other notifications.
 */
void ocpp_configure_task_notification(TaskHandle_t task, uint offset);

/**
 * Used for initial boot.
 */
int complete_boot_notification_process(const char * charge_box_serial_number, const char * charge_point_model,
				const char * charge_point_serial_number, const char * charge_point_vendor,
				const char * firmware_version, const char * iccid, const char * imsi,
				const char * meter_serial_number, const char * meter_type);

/**
 * Used by complete_boot_notification_process and when requested with trigger message.
 */
int enqueue_boot_notification();

int start_ocpp_heartbeat(void);
void ocpp_heartbeat();
void stop_ocpp_heartbeat(void);
void update_heartbeat_timer(uint sec);

void update_transaction_message_related_config(uint8_t ocpp_transaction_message_attempts, uint16_t ocpp_transaction_message_retry_interval);

enum ocpp_registration_status get_registration_status(void);

enum ocpp_task_event{
	eOCPP_TASK_CALL_ENQUEUED = 1<<0,
	eOCPP_TASK_FAILURE = 1<<1
};

#endif /* OCPP_TASK_H */
