/**
 * Capabilities.c
 * This file has been autogenerated using quicktype https://github.com/quicktype/quicktype - DO NOT EDIT
 * This file depends of https://github.com/DaveGamble/cJSON, https://github.com/joelguittet/c-list and https://github.com/joelguittet/c-hashtable
 * To parse json data from json string use the following: struct <type> * data = cJSON_Parse<type>(<string>);
 * To get json data from cJSON object use the following: struct <type> * data = cJSON_Get<type>Value(<cjson>);
 * To get cJSON object from json data use the following: cJSON * cjson = cJSON_Create<type>(<data>);
 * To print json string from json data use the following: char * string = cJSON_Print<type>(<data>);
 * To delete json data use the following: cJSON_Delete<type>(<data>);
 */

#ifndef __CAPABILITIES_C__
#define __CAPABILITIES_C__

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>
#include <cJSON.h>
// #include <hashtable.h>
#include <list.h>

#ifndef cJSON_Bool
#define cJSON_Bool (cJSON_True | cJSON_False)
#endif
#ifndef cJSON_Map
#define cJSON_Map (1 << 16)
#endif
#ifndef cJSON_Enum
#define cJSON_Enum (1 << 17)
#endif

enum CommunicationMode {
    COMMUNICATIONMODE_ETHERNET,
    COMMUNICATIONMODE_LTE,
    COMMUNICATIONMODE_PLC,
    COMMUNICATIONMODE_WI_FI,
};

enum CommunicationSharingMode {
    COMMUNICATIONSHARINGMODE_PLC_WI_FI,
    COMMUNICATIONSHARINGMODE_WI_FI_PLC,
};

/**
 * What connector is used to connect the charger to the car
 */
enum ConnectorType {
    CONNECTORTYPE_INTEGRATED,
    CONNECTORTYPE_ITT_SOCKET,
    CONNECTORTYPE_SCAME_SHUTTER_SOCKET,
};

/**
 * Indicates the device type.
 */
enum DeviceType {
    DEVICETYPE_GO,
    DEVICETYPE_PRO,
};

enum GridType {
    GRIDTYPE_IT_1,
    GRIDTYPE_IT_3,
    GRIDTYPE_TN_1,
    GRIDTYPE_TN_3,
};

/**
 * Internal, "high level", hardware variant related to architecture of the hardware.
 */
enum HardwareVariant {
    HARDWAREVARIANT_COSTCUT,
    HARDWAREVARIANT_ORIGINAL,
};

/**
 * Indicates which type of fuse is included in the charger (if any)
 */
enum InternalFuse {
    INTERNALFUSE_NONE,
    INTERNALFUSE_RESETTABLE_C_32_A,
    INTERNALFUSE_RESETTABLE_C_40_A,
    INTERNALFUSE_UNKNOWN,
};

enum OcppVersion {
    OCPPVERSION_V1_6,
    OCPPVERSION_V2_0_1,
};

/**
 * Indicates the product based on how it looks/was sold to the customer.
 */
enum ProductVariant {
    PRODUCTVARIANT_HOME,
    PRODUCTVARIANT_PRO,
    PRODUCTVARIANT_PRO2,
    PRODUCTVARIANT_PRO_MID,
    PRODUCTVARIANT_PRO_T2_S,
};

/**
 * Indicates the type of RCD (Residual current device) included in the charger
 */
enum RcdType {
    RCDTYPE_NONE,
    RCDTYPE_RDC_DD,
    RCDTYPE_TYPE_B,
    RCDTYPE_UNKNOWN,
};

/**
 * Indicates the version of JSON schema used in capabilities. This is defined as an enum,
 * and it has to be incremented if the schema changes. This is used to ensure that the
 * capabilities are compatible with the schema used by the client.
 */
enum SchemaVersion {
    SCHEMAVERSION_THE_200,
};

struct Capabilities {
    /**
     * Indicates which mode(s) of communication the device can use to connect to the internet
     */
    list_t * communication_modes;
    /**
     * Indicates what types of communication can be bridged.
     */
    list_t * communication_sharing_modes;
    /**
     * What connector is used to connect the charger to the car
     */
    enum ConnectorType * connector_type;
    /**
     * Indicates the device type.
     */
    enum DeviceType * device_type;
    /**
     * Indicates which grid types this charger is capable of supporting. Note that even if a
     * charger supports a grid type, it doesn't mean that it is able to charge on it (e.g. a Go
     * which supports TN_3 might be installed with only one phase. To further complicate, that
     * charger could _also_ have phase rotation applied). Most chargers support all grid types,
     * but some notable exceptions are: Pro T2S (no IT support), Go O-PEN (1-phase only).
     */
    list_t * grid_types;
    /**
     * Internal, "high level", hardware variant related to architecture of the hardware.
     */
    enum HardwareVariant * hardware_variant;
    /**
     * Indicates which type of fuse is included in the charger (if any)
     */
    enum InternalFuse * internal_fuse;
    /**
     * Indicates if energy meter on this charger has been calibrated. Note that this does not
     * mean the charger is MID certified.
     */
    bool * meter_calibrated;
    /**
     * Indicates if charger has been certified according to the MID.
     */
    bool * mid_certified;
    /**
     * Indicates the supported OCPP versions.
     */
    list_t * ocpp_versions;
    /**
     * Indicates the product based on how it looks/was sold to the customer.
     */
    enum ProductVariant * product_variant;
    /**
     * Indicates the type of RCD (Residual current device) included in the charger
     */
    enum RcdType * rcd_type;
    /**
     * Indicates the version of JSON schema used in capabilities. This is defined as an enum,
     * and it has to be incremented if the schema changes. This is used to ensure that the
     * capabilities are compatible with the schema used by the client.
     */
    enum SchemaVersion schema_version;
};

enum CommunicationMode cJSON_GetCommunicationModeValue(const cJSON * j);
cJSON * cJSON_CreateCommunicationMode(const enum CommunicationMode x);

enum CommunicationSharingMode cJSON_GetCommunicationSharingModeValue(const cJSON * j);
cJSON * cJSON_CreateCommunicationSharingMode(const enum CommunicationSharingMode x);

enum ConnectorType cJSON_GetConnectorTypeValue(const cJSON * j);
cJSON * cJSON_CreateConnectorType(const enum ConnectorType x);

enum DeviceType cJSON_GetDeviceTypeValue(const cJSON * j);
cJSON * cJSON_CreateDeviceType(const enum DeviceType x);

enum GridType cJSON_GetGridTypeValue(const cJSON * j);
cJSON * cJSON_CreateGridType(const enum GridType x);

enum HardwareVariant cJSON_GetHardwareVariantValue(const cJSON * j);
cJSON * cJSON_CreateHardwareVariant(const enum HardwareVariant x);

enum InternalFuse cJSON_GetInternalFuseValue(const cJSON * j);
cJSON * cJSON_CreateInternalFuse(const enum InternalFuse x);

enum OcppVersion cJSON_GetOcppVersionValue(const cJSON * j);
cJSON * cJSON_CreateOcppVersion(const enum OcppVersion x);

enum ProductVariant cJSON_GetProductVariantValue(const cJSON * j);
cJSON * cJSON_CreateProductVariant(const enum ProductVariant x);

enum RcdType cJSON_GetRcdTypeValue(const cJSON * j);
cJSON * cJSON_CreateRcdType(const enum RcdType x);

enum SchemaVersion cJSON_GetSchemaVersionValue(const cJSON * j);
cJSON * cJSON_CreateSchemaVersion(const enum SchemaVersion x);

struct Capabilities * cJSON_ParseCapabilities(const char * s);
struct Capabilities * cJSON_GetCapabilitiesValue(const cJSON * j);
cJSON * cJSON_CreateCapabilities(const struct Capabilities * x);
char * cJSON_PrintCapabilities(const struct Capabilities * x);
void cJSON_DeleteCapabilities(struct Capabilities * x);

enum CommunicationMode cJSON_GetCommunicationModeValue(const cJSON * j) {
    enum CommunicationMode x = 0;
    if (NULL != j) {
        if (!strcmp(cJSON_GetStringValue(j), "Ethernet")) x = COMMUNICATIONMODE_ETHERNET;
        else if (!strcmp(cJSON_GetStringValue(j), "LTE")) x = COMMUNICATIONMODE_LTE;
        else if (!strcmp(cJSON_GetStringValue(j), "PLC")) x = COMMUNICATIONMODE_PLC;
        else if (!strcmp(cJSON_GetStringValue(j), "WiFi")) x = COMMUNICATIONMODE_WI_FI;
    }
    return x;
}

cJSON * cJSON_CreateCommunicationMode(const enum CommunicationMode x) {
    cJSON * j = NULL;
    switch (x) {
        case COMMUNICATIONMODE_ETHERNET: j = cJSON_CreateString("Ethernet"); break;
        case COMMUNICATIONMODE_LTE: j = cJSON_CreateString("LTE"); break;
        case COMMUNICATIONMODE_PLC: j = cJSON_CreateString("PLC"); break;
        case COMMUNICATIONMODE_WI_FI: j = cJSON_CreateString("WiFi"); break;
    }
    return j;
}

enum CommunicationSharingMode cJSON_GetCommunicationSharingModeValue(const cJSON * j) {
    enum CommunicationSharingMode x = 0;
    if (NULL != j) {
        if (!strcmp(cJSON_GetStringValue(j), "PLC_WiFi")) x = COMMUNICATIONSHARINGMODE_PLC_WI_FI;
        else if (!strcmp(cJSON_GetStringValue(j), "WiFi_PLC")) x = COMMUNICATIONSHARINGMODE_WI_FI_PLC;
    }
    return x;
}

cJSON * cJSON_CreateCommunicationSharingMode(const enum CommunicationSharingMode x) {
    cJSON * j = NULL;
    switch (x) {
        case COMMUNICATIONSHARINGMODE_PLC_WI_FI: j = cJSON_CreateString("PLC_WiFi"); break;
        case COMMUNICATIONSHARINGMODE_WI_FI_PLC: j = cJSON_CreateString("WiFi_PLC"); break;
    }
    return j;
}

enum ConnectorType cJSON_GetConnectorTypeValue(const cJSON * j) {
    enum ConnectorType x = 0;
    if (NULL != j) {
        if (!strcmp(cJSON_GetStringValue(j), "Integrated")) x = CONNECTORTYPE_INTEGRATED;
        else if (!strcmp(cJSON_GetStringValue(j), "ITT_Socket")) x = CONNECTORTYPE_ITT_SOCKET;
        else if (!strcmp(cJSON_GetStringValue(j), "SCAME_Shutter_Socket")) x = CONNECTORTYPE_SCAME_SHUTTER_SOCKET;
    }
    return x;
}

cJSON * cJSON_CreateConnectorType(const enum ConnectorType x) {
    cJSON * j = NULL;
    switch (x) {
        case CONNECTORTYPE_INTEGRATED: j = cJSON_CreateString("Integrated"); break;
        case CONNECTORTYPE_ITT_SOCKET: j = cJSON_CreateString("ITT_Socket"); break;
        case CONNECTORTYPE_SCAME_SHUTTER_SOCKET: j = cJSON_CreateString("SCAME_Shutter_Socket"); break;
    }
    return j;
}

enum DeviceType cJSON_GetDeviceTypeValue(const cJSON * j) {
    enum DeviceType x = 0;
    if (NULL != j) {
        if (!strcmp(cJSON_GetStringValue(j), "Go")) x = DEVICETYPE_GO;
        else if (!strcmp(cJSON_GetStringValue(j), "Pro")) x = DEVICETYPE_PRO;
    }
    return x;
}

cJSON * cJSON_CreateDeviceType(const enum DeviceType x) {
    cJSON * j = NULL;
    switch (x) {
        case DEVICETYPE_GO: j = cJSON_CreateString("Go"); break;
        case DEVICETYPE_PRO: j = cJSON_CreateString("Pro"); break;
    }
    return j;
}

enum GridType cJSON_GetGridTypeValue(const cJSON * j) {
    enum GridType x = 0;
    if (NULL != j) {
        if (!strcmp(cJSON_GetStringValue(j), "IT_1")) x = GRIDTYPE_IT_1;
        else if (!strcmp(cJSON_GetStringValue(j), "IT_3")) x = GRIDTYPE_IT_3;
        else if (!strcmp(cJSON_GetStringValue(j), "TN_1")) x = GRIDTYPE_TN_1;
        else if (!strcmp(cJSON_GetStringValue(j), "TN_3")) x = GRIDTYPE_TN_3;
    }
    return x;
}

cJSON * cJSON_CreateGridType(const enum GridType x) {
    cJSON * j = NULL;
    switch (x) {
        case GRIDTYPE_IT_1: j = cJSON_CreateString("IT_1"); break;
        case GRIDTYPE_IT_3: j = cJSON_CreateString("IT_3"); break;
        case GRIDTYPE_TN_1: j = cJSON_CreateString("TN_1"); break;
        case GRIDTYPE_TN_3: j = cJSON_CreateString("TN_3"); break;
    }
    return j;
}

enum HardwareVariant cJSON_GetHardwareVariantValue(const cJSON * j) {
    enum HardwareVariant x = 0;
    if (NULL != j) {
        if (!strcmp(cJSON_GetStringValue(j), "Costcut")) x = HARDWAREVARIANT_COSTCUT;
        else if (!strcmp(cJSON_GetStringValue(j), "Original")) x = HARDWAREVARIANT_ORIGINAL;
    }
    return x;
}

cJSON * cJSON_CreateHardwareVariant(const enum HardwareVariant x) {
    cJSON * j = NULL;
    switch (x) {
        case HARDWAREVARIANT_COSTCUT: j = cJSON_CreateString("Costcut"); break;
        case HARDWAREVARIANT_ORIGINAL: j = cJSON_CreateString("Original"); break;
    }
    return j;
}

enum InternalFuse cJSON_GetInternalFuseValue(const cJSON * j) {
    enum InternalFuse x = 0;
    if (NULL != j) {
        if (!strcmp(cJSON_GetStringValue(j), "None")) x = INTERNALFUSE_NONE;
        else if (!strcmp(cJSON_GetStringValue(j), "Resettable_C_32A")) x = INTERNALFUSE_RESETTABLE_C_32_A;
        else if (!strcmp(cJSON_GetStringValue(j), "Resettable_C_40A")) x = INTERNALFUSE_RESETTABLE_C_40_A;
        else if (!strcmp(cJSON_GetStringValue(j), "Unknown")) x = INTERNALFUSE_UNKNOWN;
    }
    return x;
}

cJSON * cJSON_CreateInternalFuse(const enum InternalFuse x) {
    cJSON * j = NULL;
    switch (x) {
        case INTERNALFUSE_NONE: j = cJSON_CreateString("None"); break;
        case INTERNALFUSE_RESETTABLE_C_32_A: j = cJSON_CreateString("Resettable_C_32A"); break;
        case INTERNALFUSE_RESETTABLE_C_40_A: j = cJSON_CreateString("Resettable_C_40A"); break;
        case INTERNALFUSE_UNKNOWN: j = cJSON_CreateString("Unknown"); break;
    }
    return j;
}

enum OcppVersion cJSON_GetOcppVersionValue(const cJSON * j) {
    enum OcppVersion x = 0;
    if (NULL != j) {
        if (!strcmp(cJSON_GetStringValue(j), "V1_6")) x = OCPPVERSION_V1_6;
        else if (!strcmp(cJSON_GetStringValue(j), "V2_0_1")) x = OCPPVERSION_V2_0_1;
    }
    return x;
}

cJSON * cJSON_CreateOcppVersion(const enum OcppVersion x) {
    cJSON * j = NULL;
    switch (x) {
        case OCPPVERSION_V1_6: j = cJSON_CreateString("V1_6"); break;
        case OCPPVERSION_V2_0_1: j = cJSON_CreateString("V2_0_1"); break;
    }
    return j;
}

enum ProductVariant cJSON_GetProductVariantValue(const cJSON * j) {
    enum ProductVariant x = 0;
    if (NULL != j) {
        if (!strcmp(cJSON_GetStringValue(j), "Home")) x = PRODUCTVARIANT_HOME;
        else if (!strcmp(cJSON_GetStringValue(j), "Pro")) x = PRODUCTVARIANT_PRO;
        else if (!strcmp(cJSON_GetStringValue(j), "Pro2")) x = PRODUCTVARIANT_PRO2;
        else if (!strcmp(cJSON_GetStringValue(j), "ProMID")) x = PRODUCTVARIANT_PRO_MID;
        else if (!strcmp(cJSON_GetStringValue(j), "ProT2S")) x = PRODUCTVARIANT_PRO_T2_S;
    }
    return x;
}

cJSON * cJSON_CreateProductVariant(const enum ProductVariant x) {
    cJSON * j = NULL;
    switch (x) {
        case PRODUCTVARIANT_HOME: j = cJSON_CreateString("Home"); break;
        case PRODUCTVARIANT_PRO: j = cJSON_CreateString("Pro"); break;
        case PRODUCTVARIANT_PRO2: j = cJSON_CreateString("Pro2"); break;
        case PRODUCTVARIANT_PRO_MID: j = cJSON_CreateString("ProMID"); break;
        case PRODUCTVARIANT_PRO_T2_S: j = cJSON_CreateString("ProT2S"); break;
    }
    return j;
}

enum RcdType cJSON_GetRcdTypeValue(const cJSON * j) {
    enum RcdType x = 0;
    if (NULL != j) {
        if (!strcmp(cJSON_GetStringValue(j), "None")) x = RCDTYPE_NONE;
        else if (!strcmp(cJSON_GetStringValue(j), "RDC_DD")) x = RCDTYPE_RDC_DD;
        else if (!strcmp(cJSON_GetStringValue(j), "TypeB")) x = RCDTYPE_TYPE_B;
        else if (!strcmp(cJSON_GetStringValue(j), "Unknown")) x = RCDTYPE_UNKNOWN;
    }
    return x;
}

cJSON * cJSON_CreateRcdType(const enum RcdType x) {
    cJSON * j = NULL;
    switch (x) {
        case RCDTYPE_NONE: j = cJSON_CreateString("None"); break;
        case RCDTYPE_RDC_DD: j = cJSON_CreateString("RDC_DD"); break;
        case RCDTYPE_TYPE_B: j = cJSON_CreateString("TypeB"); break;
        case RCDTYPE_UNKNOWN: j = cJSON_CreateString("Unknown"); break;
    }
    return j;
}

enum SchemaVersion cJSON_GetSchemaVersionValue(const cJSON * j) {
    enum SchemaVersion x = 0;
    if (NULL != j) {
        if (!strcmp(cJSON_GetStringValue(j), "2.0.0")) x = SCHEMAVERSION_THE_200;
    }
    return x;
}

cJSON * cJSON_CreateSchemaVersion(const enum SchemaVersion x) {
    cJSON * j = NULL;
    switch (x) {
        case SCHEMAVERSION_THE_200: j = cJSON_CreateString("2.0.0"); break;
    }
    return j;
}

struct Capabilities * cJSON_ParseCapabilities(const char * s) {
    struct Capabilities * x = NULL;
    if (NULL != s) {
        cJSON * j = cJSON_Parse(s);
        if (NULL != j) {
            x = cJSON_GetCapabilitiesValue(j);
            cJSON_Delete(j);
        }
    }
    return x;
}

struct Capabilities * cJSON_GetCapabilitiesValue(const cJSON * j) {
    struct Capabilities * x = NULL;
    if (NULL != j) {
        if (NULL != (x = cJSON_malloc(sizeof(struct Capabilities)))) {
            memset(x, 0, sizeof(struct Capabilities));
            if (cJSON_HasObjectItem(j, "CommunicationModes")) {
                list_t * x1 = list_create(false, NULL);
                if (NULL != x1) {
                    cJSON * e1 = NULL;
                    cJSON * j1 = cJSON_GetObjectItemCaseSensitive(j, "CommunicationModes");
                    cJSON_ArrayForEach(e1, j1) {
                        enum CommunicationMode * tmp = cJSON_malloc(sizeof(enum CommunicationMode));
                        if (NULL != tmp) {
                            * tmp = cJSON_GetCommunicationModeValue(e1);
                            list_add_tail(x1, tmp, sizeof(enum CommunicationMode *));
                        }
                    }
                    x->communication_modes = x1;
                }
            }
            if (cJSON_HasObjectItem(j, "CommunicationSharingModes")) {
                list_t * x1 = list_create(false, NULL);
                if (NULL != x1) {
                    cJSON * e1 = NULL;
                    cJSON * j1 = cJSON_GetObjectItemCaseSensitive(j, "CommunicationSharingModes");
                    cJSON_ArrayForEach(e1, j1) {
                        enum CommunicationSharingMode * tmp = cJSON_malloc(sizeof(enum CommunicationSharingMode));
                        if (NULL != tmp) {
                            * tmp = cJSON_GetCommunicationSharingModeValue(e1);
                            list_add_tail(x1, tmp, sizeof(enum CommunicationSharingMode *));
                        }
                    }
                    x->communication_sharing_modes = x1;
                }
            }
            if (cJSON_HasObjectItem(j, "ConnectorType")) {
                if (NULL != (x->connector_type = cJSON_malloc(sizeof(enum ConnectorType)))) {
                    *x->connector_type = cJSON_GetConnectorTypeValue(cJSON_GetObjectItemCaseSensitive(j, "ConnectorType"));
                }
            }
            if (cJSON_HasObjectItem(j, "DeviceType")) {
                if (NULL != (x->device_type = cJSON_malloc(sizeof(enum DeviceType)))) {
                    *x->device_type = cJSON_GetDeviceTypeValue(cJSON_GetObjectItemCaseSensitive(j, "DeviceType"));
                }
            }
            if (cJSON_HasObjectItem(j, "GridTypes")) {
                list_t * x1 = list_create(false, NULL);
                if (NULL != x1) {
                    cJSON * e1 = NULL;
                    cJSON * j1 = cJSON_GetObjectItemCaseSensitive(j, "GridTypes");
                    cJSON_ArrayForEach(e1, j1) {
                        enum GridType * tmp = cJSON_malloc(sizeof(enum GridType));
                        if (NULL != tmp) {
                            * tmp = cJSON_GetGridTypeValue(e1);
                            list_add_tail(x1, tmp, sizeof(enum GridType *));
                        }
                    }
                    x->grid_types = x1;
                }
            }
            if (cJSON_HasObjectItem(j, "HardwareVariant")) {
                if (NULL != (x->hardware_variant = cJSON_malloc(sizeof(enum HardwareVariant)))) {
                    *x->hardware_variant = cJSON_GetHardwareVariantValue(cJSON_GetObjectItemCaseSensitive(j, "HardwareVariant"));
                }
            }
            if (cJSON_HasObjectItem(j, "InternalFuse")) {
                if (NULL != (x->internal_fuse = cJSON_malloc(sizeof(enum InternalFuse)))) {
                    *x->internal_fuse = cJSON_GetInternalFuseValue(cJSON_GetObjectItemCaseSensitive(j, "InternalFuse"));
                }
            }
            if (cJSON_HasObjectItem(j, "MeterCalibrated")) {
                if (NULL != (x->meter_calibrated = cJSON_malloc(sizeof(bool)))) {
                    *x->meter_calibrated = cJSON_IsTrue(cJSON_GetObjectItemCaseSensitive(j, "MeterCalibrated"));
                }
            }
            if (cJSON_HasObjectItem(j, "MIDCertified")) {
                if (NULL != (x->mid_certified = cJSON_malloc(sizeof(bool)))) {
                    *x->mid_certified = cJSON_IsTrue(cJSON_GetObjectItemCaseSensitive(j, "MIDCertified"));
                }
            }
            if (cJSON_HasObjectItem(j, "OcppVersions")) {
                list_t * x1 = list_create(false, NULL);
                if (NULL != x1) {
                    cJSON * e1 = NULL;
                    cJSON * j1 = cJSON_GetObjectItemCaseSensitive(j, "OcppVersions");
                    cJSON_ArrayForEach(e1, j1) {
                        enum OcppVersion * tmp = cJSON_malloc(sizeof(enum OcppVersion));
                        if (NULL != tmp) {
                            * tmp = cJSON_GetOcppVersionValue(e1);
                            list_add_tail(x1, tmp, sizeof(enum OcppVersion *));
                        }
                    }
                    x->ocpp_versions = x1;
                }
            }
            if (cJSON_HasObjectItem(j, "ProductVariant")) {
                if (NULL != (x->product_variant = cJSON_malloc(sizeof(enum ProductVariant)))) {
                    *x->product_variant = cJSON_GetProductVariantValue(cJSON_GetObjectItemCaseSensitive(j, "ProductVariant"));
                }
            }
            if (cJSON_HasObjectItem(j, "RCDType")) {
                if (NULL != (x->rcd_type = cJSON_malloc(sizeof(enum RcdType)))) {
                    *x->rcd_type = cJSON_GetRcdTypeValue(cJSON_GetObjectItemCaseSensitive(j, "RCDType"));
                }
            }
            if (cJSON_HasObjectItem(j, "SchemaVersion")) {
                x->schema_version = cJSON_GetSchemaVersionValue(cJSON_GetObjectItemCaseSensitive(j, "SchemaVersion"));
            }
        }
    }
    return x;
}

cJSON * cJSON_CreateCapabilities(const struct Capabilities * x) {
    cJSON * j = NULL;
    if (NULL != x) {
        if (NULL != (j = cJSON_CreateObject())) {
            if (NULL != x->communication_modes) {
                cJSON * j1 = cJSON_AddArrayToObject(j, "CommunicationModes");
                if (NULL != j1) {
                    enum CommunicationMode * x1 = list_get_head(x->communication_modes);
                    while (NULL != x1) {
                        cJSON_AddItemToArray(j1, cJSON_CreateCommunicationMode(*x1));
                        x1 = list_get_next(x->communication_modes);
                    }
                }
            }
            if (NULL != x->communication_sharing_modes) {
                cJSON * j1 = cJSON_AddArrayToObject(j, "CommunicationSharingModes");
                if (NULL != j1) {
                    enum CommunicationSharingMode * x1 = list_get_head(x->communication_sharing_modes);
                    while (NULL != x1) {
                        cJSON_AddItemToArray(j1, cJSON_CreateCommunicationSharingMode(*x1));
                        x1 = list_get_next(x->communication_sharing_modes);
                    }
                }
            }
            if (NULL != x->connector_type) {
                cJSON_AddItemToObject(j, "ConnectorType", cJSON_CreateConnectorType(*x->connector_type));
            }
            if (NULL != x->device_type) {
                cJSON_AddItemToObject(j, "DeviceType", cJSON_CreateDeviceType(*x->device_type));
            }
            if (NULL != x->grid_types) {
                cJSON * j1 = cJSON_AddArrayToObject(j, "GridTypes");
                if (NULL != j1) {
                    enum GridType * x1 = list_get_head(x->grid_types);
                    while (NULL != x1) {
                        cJSON_AddItemToArray(j1, cJSON_CreateGridType(*x1));
                        x1 = list_get_next(x->grid_types);
                    }
                }
            }
            if (NULL != x->hardware_variant) {
                cJSON_AddItemToObject(j, "HardwareVariant", cJSON_CreateHardwareVariant(*x->hardware_variant));
            }
            if (NULL != x->internal_fuse) {
                cJSON_AddItemToObject(j, "InternalFuse", cJSON_CreateInternalFuse(*x->internal_fuse));
            }
            if (NULL != x->meter_calibrated) {
                cJSON_AddBoolToObject(j, "MeterCalibrated", *x->meter_calibrated);
            }
            if (NULL != x->mid_certified) {
                cJSON_AddBoolToObject(j, "MIDCertified", *x->mid_certified);
            }
            if (NULL != x->ocpp_versions) {
                cJSON * j1 = cJSON_AddArrayToObject(j, "OcppVersions");
                if (NULL != j1) {
                    enum OcppVersion * x1 = list_get_head(x->ocpp_versions);
                    while (NULL != x1) {
                        cJSON_AddItemToArray(j1, cJSON_CreateOcppVersion(*x1));
                        x1 = list_get_next(x->ocpp_versions);
                    }
                }
            }
            if (NULL != x->product_variant) {
                cJSON_AddItemToObject(j, "ProductVariant", cJSON_CreateProductVariant(*x->product_variant));
            }
            if (NULL != x->rcd_type) {
                cJSON_AddItemToObject(j, "RCDType", cJSON_CreateRcdType(*x->rcd_type));
            }
            cJSON_AddItemToObject(j, "SchemaVersion", cJSON_CreateSchemaVersion(x->schema_version));
        }
    }
    return j;
}

char * cJSON_PrintCapabilities(const struct Capabilities * x) {
    char * s = NULL;
    if (NULL != x) {
        cJSON * j = cJSON_CreateCapabilities(x);
        if (NULL != j) {
            s = cJSON_Print(j);
            cJSON_Delete(j);
        }
    }
    return s;
}

void cJSON_DeleteCapabilities(struct Capabilities * x) {
    if (NULL != x) {
        if (NULL != x->communication_modes) {
            enum CommunicationMode * x1 = list_get_head(x->communication_modes);
            while (NULL != x1) {
                cJSON_free(x1);
                x1 = list_get_next(x->communication_modes);
            }
            list_release(x->communication_modes);
        }
        if (NULL != x->communication_sharing_modes) {
            enum CommunicationSharingMode * x1 = list_get_head(x->communication_sharing_modes);
            while (NULL != x1) {
                cJSON_free(x1);
                x1 = list_get_next(x->communication_sharing_modes);
            }
            list_release(x->communication_sharing_modes);
        }
        if (NULL != x->connector_type) {
            cJSON_free(x->connector_type);
        }
        if (NULL != x->device_type) {
            cJSON_free(x->device_type);
        }
        if (NULL != x->grid_types) {
            enum GridType * x1 = list_get_head(x->grid_types);
            while (NULL != x1) {
                cJSON_free(x1);
                x1 = list_get_next(x->grid_types);
            }
            list_release(x->grid_types);
        }
        if (NULL != x->hardware_variant) {
            cJSON_free(x->hardware_variant);
        }
        if (NULL != x->internal_fuse) {
            cJSON_free(x->internal_fuse);
        }
        if (NULL != x->meter_calibrated) {
            cJSON_free(x->meter_calibrated);
        }
        if (NULL != x->mid_certified) {
            cJSON_free(x->mid_certified);
        }
        if (NULL != x->ocpp_versions) {
            enum OcppVersion * x1 = list_get_head(x->ocpp_versions);
            while (NULL != x1) {
                cJSON_free(x1);
                x1 = list_get_next(x->ocpp_versions);
            }
            list_release(x->ocpp_versions);
        }
        if (NULL != x->product_variant) {
            cJSON_free(x->product_variant);
        }
        if (NULL != x->rcd_type) {
            cJSON_free(x->rcd_type);
        }
        cJSON_free(x);
    }
}

#ifdef __cplusplus
}
#endif

#endif /* __CAPABILITIES_C__ */
