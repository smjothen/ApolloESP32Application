# OTA

The OTA feature of the Apollo project provides the possibility to update the firmware in the devices. There are two primary design concerns:
- We are running code on two different micro controllers. We need to update both, with appropriate preconditions, postconditions and synchronization of update stages between the to controllers.
- Since the products are updated remotely we need a resilient system that does not brick the device, and makes sure future updates can be installed.

This document details some of the design considerations for the system in its current state. A pre-implementation spec exists at https://zapzone.zaptec.com/display/AP/Apollo+software+Over-The-Air%28OTA%29+upgrade+procedure . While there is some overlap between these documents, this documents describes the implementation as built, with the limitations and design choices made during the implementation.

## OTA process overview
### OTA initiation
The ESP32 is updated first, using this process:
1. The OTA process starts when a command is issued over the MQTT connection to the cloud.
2. Then the ESP32 fetches the location of the image to be installed. This URL is passed to the OTA client from the ESP32 SDK.
3. The client downloads and installs the new image to the ESP32. 
4. The ESP32 reboots. The dsPIC syncing process, described below, always happens when the ESP32 boots.
5. If the ESP32 manages to complete the startup process, it will as the last step of the initialization mark the new firmware as valid. This ensures that it is not marked as valid before it is known that both the ESP32 and the dsPIC can start the new firmware.

### dsPIC syncing
The FW for the dsPIC is built in to the ESP32 image. On startup the ESP32 runs through these steps:
1. Check if the dsPIC image currently running is the same image as embedded in the ESP32 firmware.
2. Check that the dsPIC can boot this image.
3. If the checks fail, the ESP32 flashes the dsPIC and boots it.

This ensures that the dsPIC always run the expected FW.

## ESP32 bootloader and OTA client

The ESP32 downloads and installs the new image as part of its application code. Then the SDK-provided bootloader selects which partition to boot, and keeps track of the need for firmware validation etc. The OTA process is based on https://dcs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/system/esp_https_ota.html , which is a simplified API built on top of a lower level OTA library also included in the SDK.

### Improvements
- Improve ota client of image, to better endure flaky internet connections. E.g. by:
    - supporting partial downloads of the image
    - supporting download while allowing charging
- Exit OTA on many failures ( on failure count or timeout).


## dsPIC bootloader
`ApolloMCUApplication/mccbootloader`

### MCC
MCC provides the drivers for the dsPIC bootloader code.

### Interrupts
Each interrupt jumps to the address kept at the corresponding location in the interrupt vector table (IVT). These addresses are defined in the bootloader linker script. Note:
- Each IVT element is an address in the application image.
- The list of addresses are generated with `ApolloMCUApplication/blhost/create_ivt.py`.
- By default the linker script no longer uses the IVT defined in it, I removed this check: `#if __XC16_VERSION < 1026`.
- At each address defined in the IVT there is a `goto` instruction that takes the dsPIC to the IRQ handler.
    - the linker section with the `goto`s is called `j_ivt`
    - these are generated by `ApolloMCUApplication/blhost/create_j_ivt.py`
- the alternate IVT is not used
- the bootloader has no interrupts, although it could if it had a flag that would cause it to pass along the requests to the application after it has started.


### Long jump
When the dsPIC starts the application code it uses the following snippet:
```C
int (*user_application)(void);
user_application = (int(*)(void))0x4000;
user_application();
```
It does _not_ use the reset vector

### Image header
After flashing the application, the ESP32 sends:
- the length of the application
- its CRC of the application

These values are stored if the received CRC matches the CRC calculated from the flash. The stored values are used for:
- Validating the integrity of the application on normal boot.
- Validating the integrity of the application before starting it when the ESP32 commanded it to do so.
- Defining the currently installed application; the CRC is returned when the ESP32 asks for the version of the current image.
### Flash layout
The flash layout, the constants defining it, and the alignments should probably be cleaned up some. The current layout is as follows:

| Location | length | content | notes |
| -------: | -----: | ------- | ----- |
|     0x4  |  0x1FC | IVT as described above | |
|     0x200  |  0x3600 | bootloader program | probably can be shrunken a lot, start by removing printf |
|     0x3800   |  | Start of region erased by bootloader  | the flash erase page size is quite large, at 2048 bytes|
|     0x3800 |  0x2 | application image header | |
|     0x3c00 |  0x330 | `j_ivt` as described above | |
|     0x4000 |  0x27800 | start of application program | |
|     0x2b800|  0x700 | persisted data | not defined in linker script, reserved by setting app size |


### Shrinking the app size
The application size can be reduced by making these changes:
- reduce length in the linker script
- set corresponding range in the `hex2bin.py` command

The build system places data at both ends of the area for the application. I.e. it does not put all the program data in a continuous region. Since the steps above reduces the memory regions that are available to the linker, it has the effect of making a more compact application.

A shrunken app has the following benefits:
- less data to transfer on the cellular network
- faster transfer of application from ESP to dsPIC
- smaller chance of CRC check failure du to errors in unused memory area

 
### Building and image creation
The linker script for the bootloader is at `ApolloMCUApplication/mccbootloader/mccbootlader.X/p33CK256MP506.gld`. When building a "bootloadable" version of the app the linker script at `/home/arnt/zaptec/ApolloMCUApplication/smart/smart/p33CK256MP506_offset_3c00.gld` must be used. Together they ensure the flash layout described in the table above.

After building with the linker script, there will be a `.hex` file describing the full flash at `/smart/smart/dist/AppWithBootloader/production/smart.production.hex`. Some slight modifications needs to be done to this file. Use this command:

```
python /home/arnt/.local/share/virtualenvs/blhost-jQgB8x88/bin/hex2bin.py --range=0x3c00:0x56fff ../smart/smart/dist/AppWithBootloader/production/smart.production.hex  | tail -c +15361 > ../../ApolloESP32Application/bin/dspic.bin
```

This changes the file in the following ways:
- `hex2bin` go from lines with addresses and data in hex to pure binary stuff
- `--range=0x3c00:0x56fff` skip the start of the flash, this data is required if running without bootloader for development, but is not part of what is updated with the OTA image. `(0x56fff+0x1)รท0x2==0x2b800` This range works, but it seems the start address is word-indexed and the second is byte-indexed. Results obtained by trial and error ;) (update: seems --range cuts the file, and tail could/should be removed)
- `tail -c +15361` hex2bin pads the beginning of the file, here we remove that (0x3c00 +0x1 == 15361)

The file located at `ApolloESP32Application/bin/dspic.bin` is automatically built in to the ESP32 image, using this strategy: https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-guides/build-system.html#embedding-binary-data

`hex2bin.py` is part of a python package. See e.g:
- https://pypi.org/project/IntelHex/
- https://github.com/python-intelhex/intelhex
- https://python-intelhex.readthedocs.io/en/latest/part3-1.html


### Configuration bits
The system only has a single set of config bits, and the design assumes them to be unchangeable, since we don't update the bootloader. The bits are defined by the bootloader-project in normal operation, but the application-project defines them during application development, in any case the config should match to provide constant behavior.

Check for config bits with these commands:
```
grep '#pragma config' ../ApolloMCUApplication/smart/smart/ -r
grep '#pragma config' ../ApolloMCUApplication/mccbootloader/ -r
```

The config bits appear in `.hex` files with addresses in the range `0x2bf00 - ~0x2bfff`. They can also be read back with MPLAB X IDE.

### Flashing for development
The current build/flash configurations can be run in any order to place the bootloader and application on the flash.

**To disable the crc check and waiting in the bootloader edit `../ApolloMCUApplication/mccbootloader/mccbootlader.X/bootloader_conf.h`**
